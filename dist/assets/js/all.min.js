(function() {
  var app, insertData, itemLabel, prepareData,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  itemLabel = function(el) {
    var ref, ref1;
    return ((ref = el.itemLabel) != null ? ref.value : void 0) || ((ref1 = el.item.value.match("^http://www\.wikidata\.org/entity/(.+)$")) != null ? ref1[1] : void 0) || el.item.value;
  };

  prepareData = function(data) {
    var bindings, el, hasSize, i, j, len, len1, links, maxSize, minSize, nodes, size;
    hasSize = indexOf.call(data.head.vars, "size") >= 0;
    bindings = data.results.bindings;
    minSize = Infinity;
    maxSize = 0;
    nodes = {};
    if (hasSize) {
      for (i = 0, len = bindings.length; i < len; i++) {
        el = bindings[i];
        if (nodes[el.item.value]) {
          continue;
        }
        size = parseInt(el.size.value);
        if (size < minSize) {
          minSize = size;
        }
        if (size > maxSize) {
          maxSize = size;
        }
        nodes[el.item.value] = {
          name: itemLabel(el),
          url: el.item.value,
          hasLink: !!el.linkTo,
          size: size
        };
      }
    } else {
      for (j = 0, len1 = bindings.length; j < len1; j++) {
        el = bindings[j];
        nodes[el.item.value] = {
          name: itemLabel(el),
          url: el.item.value,
          hasLink: !!el.linkTo
        };
      }
    }
    links = (function() {
      var l, len2, ref, results;
      results = [];
      for (l = 0, len2 = bindings.length; l < len2; l++) {
        el = bindings[l];
        if (nodes[(ref = el.linkTo) != null ? ref.value : void 0]) {
          results.push({
            source: nodes[el.item.value],
            target: nodes[el.linkTo.value]
          });
        }
      }
      return results;
    })();
    return {
      hasSize: hasSize,
      nodes: nodes,
      links: links,
      minSize: minSize,
      maxSize: maxSize
    };
  };

  insertData = function(graph, data, activeItem, mode, sizeLogScale) {
    var arrowOffset, charge, circle, container, drag, drag_rect, force, gravity, hasSize, height, line, linkDistance, links, maxSize, minSize, node, nodeid, nodes, radius, radscaler, ref, resize, scaleRange, svg, svg_group, text, tick, tooltip, tooltipFn, transform, useGroups, useLogScale, width, zoom, zoomed;
    graph.selectAll("*").remove();
    d3.selectAll("#graph-tooltip").remove();
    if (!data || !data.head) {
      return;
    }
    ref = prepareData(data), hasSize = ref.hasSize, nodes = ref.nodes, links = ref.links, minSize = ref.minSize, maxSize = ref.maxSize;
    if (hasSize) {
      useLogScale = sizeLogScale;
      scaleRange = [3, 20];
      if (useLogScale) {
        radscaler = d3.scale.log().clamp(true).domain([Math.max(1e-12, minSize), Math.max(1e-12, maxSize)]).range(scaleRange);
      } else {
        radscaler = d3.scale.linear().domain([minSize, maxSize]).range(scaleRange);
      }
      for (nodeid in nodes) {
        node = nodes[nodeid];
        node.radius = radscaler(node.size);
      }
    }
    svg = graph.append('svg').attr({
      xmlns: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink"
    });
    tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);
    transform = function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    };
    useGroups = false;
    tick = function(e) {
      var diff, div, group, groups, k, length, ob, prod, scale, sum;
      if (useGroups) {
        groups = {};
        circle.each(function(d) {
          var group;
          group = d.name.toLowerCase() > 'k';
          if (!groups[group]) {
            groups[group] = {
              x: 0.0,
              y: 0.0,
              s: 0
            };
          }
          groups[group].x += d.x;
          groups[group].y += d.y;
          groups[group].s++;
        });
        for (group in groups) {
          ob = groups[group];
          groups[group].x /= groups[group].s;
          groups[group].y /= groups[group].s;
        }
        k = 6 * e.alpha;
        circle.each(function(d) {
          group = d.name.toLowerCase() > 'k';
          d.x = d.x * (1 - k) + groups[group].x * k;
          d.y = d.y * (1 - k) + groups[group].y * k;
          if (d.x < 0) {
            d.x += -d.x * k;
          }
          if (d.x > width) {
            d.x -= (d.x - width) * k;
          }
          if (d.y < 0) {
            d.y += -d.y * k;
          }
          if (d.y > height) {
            d.y -= (d.y - height) * k;
          }
        });
      }
      if (hasSize) {
        length = function(arg) {
          var x, y;
          x = arg.x, y = arg.y;
          return Math.sqrt(x * x + y * y);
        };
        sum = function(arg, arg1) {
          var x1, x2, y1, y2;
          x1 = arg.x, y1 = arg.y;
          x2 = arg1.x, y2 = arg1.y;
          return {
            x: x1 + x2,
            y: y1 + y2
          };
        };
        diff = function(arg, arg1) {
          var x1, x2, y1, y2;
          x1 = arg.x, y1 = arg.y;
          x2 = arg1.x, y2 = arg1.y;
          return {
            x: x1 - x2,
            y: y1 - y2
          };
        };
        prod = function(arg, scalar) {
          var x, y;
          x = arg.x, y = arg.y;
          return {
            x: x * scalar,
            y: y * scalar
          };
        };
        div = function(arg, scalar) {
          var x, y;
          x = arg.x, y = arg.y;
          return {
            x: x / scalar,
            y: y / scalar
          };
        };
        scale = function(vector, scalar) {
          return prod(vector, scalar / length(vector));
        };
        line.each(function(d) {
          var dvec, source, target;
          source = d.source, target = d.target;
          if (source.x === target.x && source.y === target.y) {
            d.sp = source;
            d.tp = target;
            return;
          }
          dvec = diff(target, source);
          d.sp = sum(source, scale(dvec, source.radius));
          d.tp = diff(target, scale(dvec, target.radius));
        }).attr({
          x1: function(arg) {
            var sp;
            sp = arg.sp;
            return sp.x;
          },
          y1: function(arg) {
            var sp;
            sp = arg.sp;
            return sp.y;
          },
          x2: function(arg) {
            var tp;
            tp = arg.tp;
            return tp.x;
          },
          y2: function(arg) {
            var tp;
            tp = arg.tp;
            return tp.y;
          }
        });
      } else {
        line.attr({
          x1: function(arg) {
            var source;
            source = arg.source;
            return source.x;
          },
          y1: function(arg) {
            var source;
            source = arg.source;
            return source.y;
          },
          x2: function(arg) {
            var target;
            target = arg.target;
            return target.x;
          },
          y2: function(arg) {
            var target;
            target = arg.target;
            return target.y;
          }
        });
      }
      circle.attr({
        transform: transform
      });
      text.attr({
        transform: transform
      });
    };
    zoomed = function() {
      container.attr('transform', "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    };
    zoom = d3.behavior.zoom().on('zoom', zoomed);
    force = d3.layout.force();
    drag = force.drag().on("dragstart", function() {
      d3.event.sourceEvent.stopPropagation();
    });
    linkDistance = useGroups ? 1 : 30;
    charge = useGroups ? -5000 : -200;
    gravity = useGroups ? .05 : .05;
    force.nodes(d3.values(nodes)).links(links).linkDistance(linkDistance).charge(charge).gravity(gravity).on('tick', tick).start();
    svg.attr("pointer-events", "all");
    svg.selectAll('*').remove();
    arrowOffset = hasSize ? 0 : 6;
    svg.append('defs').selectAll('marker').data(['direction']).enter().append('marker').attr({
      id: (function(d) {
        return d;
      }),
      viewBox: "0 -5 10 10",
      refX: 10 + arrowOffset - 1,
      markerWidth: 6,
      markerHeight: 6,
      orient: 'auto'
    }).append('path').attr({
      d: 'M0,-5L10,0L0,5'
    });
    svg_group = svg.append("g").attr("transform", "translate(0,0)").call(zoom);
    drag_rect = svg_group.append("rect").style("fill", "none");
    container = svg_group.append("g");
    line = container.append('g').selectAll('line').data(force.links()).enter().append('line').attr({
      'marker-end': 'url(#direction)'
    });
    radius = hasSize ? (function(d) {
      return d.radius;
    }) : 6;
    circle = container.append('g').selectAll('circle').data(force.nodes()).enter().append('circle').attr({
      r: radius,
      cx: (function(d) {
        return d.x;
      }),
      cy: (function(d) {
        return d.y;
      })
    });
    if (hasSize) {
      tooltipFn = function(d) {
        return d.name + "<br/>Size: " + d.size;
      };
    } else {
      tooltipFn = function(d) {
        return d.name;
      };
    }
    if (hasSize) {
      circle.on("mouseover", function(d) {
        tooltip.transition().duration(100).style("opacity", .9);
        return tooltip.html(tooltipFn(d)).style("left", (d3.event.pageX + 5) + "px").style("top", (d3.event.pageY + 5) + "px");
      }).on("mouseout", function(d) {
        return tooltip.transition().duration(200).style("opacity", 0);
      });
    }
    if (mode === 'undirected') {
      circle.classed('linked', function(o) {
        return o.hasLink;
      });
    }
    circle.classed('active', function(o) {
      return o.url.endsWith(activeItem);
    });
    circle.call(drag);
    text = container.append('g').selectAll('text').data(force.nodes()).enter().append('text').attr({
      x: 8,
      y: '.31em'
    }).text(function(d) {
      return d.name;
    }).on('click', function(o) {
      window.open(o.url);
    });
    width = height = 0;
    resize = function() {
      var sidenavWidth;
      sidenavWidth = 300;
      width = window.innerWidth - sidenavWidth;
      height = window.innerHeight;
      svg.attr({
        width: width,
        height: height
      });
      drag_rect.attr({
        width: width,
        height: height
      });
      force.size([width, height]).resume();
    };
    resize();
    d3.select(window).on('resize', resize);
  };

  app = angular.module('Graph', []);

  app.directive('graph', function() {
    return {
      restrict: 'E',
      replace: false,
      scope: {
        graphData: '=',
        activeItem: '=',
        mode: '=',
        sizeLogScale: '='
      },
      link: function(scope, element, attrs) {
        scope.$watch('graphData', function(newValue, oldValue) {
          var graph;
          graph = d3.select(element[0]);
          return insertData(graph, scope.graphData, scope.activeItem, scope.mode, scope.sizeLogScale);
        });
      }
    };
  });

}).call(this);

(function() {
  var SparqlGen, SparqlGenService;

  SparqlGen = angular.module('SparqlGen', []);

  SparqlGenService = function() {
    var capitalize, genSparqlClause, useGas;
    capitalize = function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    useGas = function(data) {
      return data.limit !== 0 || data.iterations !== 0 || data.mode === 'undirected';
    };
    genSparqlClause = function(data, mode) {
      if (mode == null) {
        mode = data.mode;
      }
      if (mode === "both") {
        return "{ " + (genSparqlClause(data, 'forward')) + " } UNION { " + (genSparqlClause(data, 'reverse')) + " }";
      } else if (!useGas(data)) {
        if (mode === "forward") {
          return "wd:" + data.item + " wdt:" + data.property + "* ?item";
        } else if (mode === "reverse") {
          return "?item wdt:" + data.property + "* wd:" + data.item;
        }
      } else {
        return "SERVICE gas:service {\n    gas:program gas:gasClass \"com.bigdata.rdf.graph.analytics.SSSP\" ;\n                gas:in wd:" + data.item + " ;\n                gas:traversalDirection \"" + (capitalize(mode)) + "\" ;\n                gas:out ?item ;\n                gas:out1 ?depth ;" + (data.iterations === 0 ? "" : "\n                gas:maxIterations " + data.iterations + " ;") + (data.limit === 0 ? "" : "\n                gas:maxVisited " + data.limit + " ;") + "\n                gas:linkType wdt:" + data.property + " .\n  }";
      }
    };
    this.generate = function(data) {
      var out;
      if (!data.item || !data.property) {
        return;
      }
      out = useGas(data) ? "PREFIX gas: <http://www.bigdata.com/rdf/gas#>\n\n" : "";
      if (data.size_property) {
        return out + ("SELECT ?item ?itemLabel ?linkTo ?size {\n  { SELECT ?item (count(distinct ?element) as ?size) {\n  " + (genSparqlClause(data)) + "\n  OPTIONAL { ?element wdt:" + data.size_property + (data.size_recursive ? '*' : '') + " ?item }\n  } GROUP BY ?item }\n  OPTIONAL { ?item wdt:" + data.property + " ?linkTo }\n  SERVICE wikibase:label {bd:serviceParam wikibase:language \"" + data.lang + "\" }\n}");
      } else {
        return out + ("SELECT ?item ?itemLabel ?linkTo {\n  " + (genSparqlClause(data)) + "\n  OPTIONAL { ?item wdt:" + data.property + " ?linkTo }\n  SERVICE wikibase:label {bd:serviceParam wikibase:language \"" + data.lang + "\" }\n}");
      }
    };
  };

  SparqlGenService.$inject = [];

  SparqlGen.service('SparqlGenService', SparqlGenService);

}).call(this);

(function() {
  var WikiTools, WikiToolsService;

  WikiTools = angular.module('WikiTools', []);

  WikiToolsService = function($log, $http, $httpParamSerializer) {
    var wdApiParams;
    wdApiParams = $httpParamSerializer({
      format: 'json',
      formatversion: 2,
      callback: 'JSON_CALLBACK'
    });
    this.createApi = function(param1, param2) {
      var ref;
      if (!param2) {
        ref = ['www', param1], param1 = ref[0], param2 = ref[1];
      }
      return "https://" + param1 + "." + param2 + ".org/w/api.php?" + wdApiParams;
    };
    this.wikidata = this.createApi('wikidata');
    this.get = function(api, params) {
      return $http.jsonp(api, {
        params: params
      });
    };
    this.searchEntities = (function(_this) {
      return function(type, query, language) {
        var error, params, success;
        params = {
          action: 'wbsearchentities',
          search: query,
          uselang: language,
          language: language,
          type: type,
          "continue": 0
        };
        success = function(response) {
          return response.data.search;
        };
        error = function(response) {
          $log.error('Request failed');
          return reject('Request failed');
        };
        return _this.get(_this.wikidata, params).then(success, error);
      };
    })(this);
    this.getEntity = (function(_this) {
      return function(what, language) {
        var error, params, success;
        params = {
          action: 'wbsearchentities',
          search: what,
          uselang: language,
          language: language,
          type: what.startsWith('Q') ? 'item' : 'property',
          limit: 1
        };
        success = function(response) {
          var out;
          if (!response.data.search) {
            return {
              id: what,
              label: what,
              lang: language
            };
          } else {
            out = response.data.search[0];
            out.lang = language;
            return out;
          }
        };
        error = function(response) {
          $log.error('Request failed');
          return reject('Request failed');
        };
        return _this.get(_this.wikidata, params).then(success, error);
      };
    })(this);
    this.wdqs = function(query) {
      return $http.get('https://query.wikidata.org/sparql', {
        params: {
          query: query
        }
      });
    };
  };

  WikiToolsService.$inject = ['$log', '$http', '$httpParamSerializer'];

  WikiTools.service('WikiToolsService', WikiToolsService);

}).call(this);

(function() {
  var FormCtrl, app;

  FormCtrl = function($scope, $log, $location, $rootScope, $mdToast, $mdDialog, WikiToolsService, SparqlGenService) {
    var dynamicFields, errorToast, fields, getDataFromUrl, key, rebuildFromUrl, regenSvg, value;
    this.modes = {
      forward: 'Forward',
      reverse: 'Reverse',
      both: 'Bidirectional',
      undirected: 'Undirected',
      wdqs: 'WDQS'
    };
    fields = {
      property: {
        type: 'property'
      },
      item: {
        type: 'item'
      },
      lang: {
        type: 'lang',
        "default": 'en'
      },
      iterations: {
        type: 'number',
        "default": 0
      },
      limit: {
        type: 'number',
        "default": 0
      },
      mode: {
        type: 'enum',
        values: this.modes,
        "default": 'forward',
        extractor: function(params) {
          return params.mode || params.direction;
        }
      },
      wdqs: {
        type: 'text'
      },
      size_property: {
        type: 'property'
      },
      size_recursive: {
        type: 'boolean'
      },
      size_log_scale: {
        type: 'boolean'
      }
    };
    getDataFromUrl = function() {
      var data, field, param, params, spec;
      params = $location.search();
      data = {};
      for (field in fields) {
        spec = fields[field];
        param = spec.extractor ? spec.extractor(params) : params[field];
        data[field] = (function() {
          switch (spec.type) {
            case 'property':
              if (/^P\d+$/.test(param || '')) {
                return param;
              } else {
                return spec["default"];
              }
            case 'item':
              if (/^Q\d+$/.test(param || '')) {
                return param;
              } else {
                return spec["default"];
              }
            case 'lang':
              if (/^[a-z-]{2,}$/.test(param || '')) {
                return param;
              } else {
                return spec["default"];
              }
            case 'number':
              if (/^\d+$/.test(param || '')) {
                return parseInt(param);
              } else {
                return spec["default"];
              }
            case 'text':
              return param || spec["default"];
            case 'enum':
              if (spec.values[param]) {
                return param;
              } else {
                return spec["default"];
              }
            case 'boolean':
              return param === 1 || param === true || param === '1' || param === 'true';
          }
        })();
      }
      if (!data.wdqs) {
        data.wdqs = SparqlGenService.generate(data);
      }
      return data;
    };
    dynamicFields = (function() {
      var ref, results;
      results = [];
      for (key in fields) {
        value = fields[key];
        if ((ref = value.type) === 'item' || ref === 'property') {
          results.push(key);
        }
      }
      return results;
    })();
    dynamicFields.forEach((function(_this) {
      return function(ob) {
        return $scope.$watch((function() {
          return _this[ob];
        }), function(name) {
          if (!name) {
            return _this[ob + 'Object'] = _this[ob + 'Text'] = void 0;
          }
          return WikiToolsService.getEntity(name, _this.lang).then(function(result) {
            return _this[ob + 'Object'] = result;
          });
        });
      };
    })(this));
    $scope.$watch(((function(_this) {
      return function() {
        return _this.lang;
      };
    })(this)), (function(_this) {
      return function(lang) {
        if (!lang) {
          return;
        }
        return dynamicFields.forEach(function(name) {
          var obname;
          obname = name + 'Object';
          if (_this[obname] && _this[obname].lang !== lang) {
            _this[obname].lang = lang;
            return WikiToolsService.getEntity(_this[obname].id, lang).then(function(result) {
              if (_this[obname].lang === lang) {
                return _this[obname] = result;
              }
            });
          }
        });
      };
    })(this));
    rebuildFromUrl = (function(_this) {
      return function() {
        var data, ref;
        data = getDataFromUrl();
        for (key in data) {
          value = data[key];
          _this[key] = value;
          if (!value && ((ref = fields[key].type) === 'item' || ref === 'property')) {
            _this[key + 'Object'] = _this[key + 'Text'] = void 0;
          }
        }
        if (!_this.validate()) {
          _this.graphData = void 0;
        }
        if (data.wdqs) {
          regenSvg(data);
        }
      };
    })(this);
    $rootScope.$on('$locationChangeSuccess', rebuildFromUrl);
    this.itemSearch = function(query) {
      return WikiToolsService.searchEntities('item', query, this.lang);
    };
    this.propertySearch = function(query) {
      return WikiToolsService.searchEntities('property', query, this.lang);
    };
    this.reset = function() {
      return $location.search({});
    };
    this.validate = function() {
      return this.mode === 'wdqs' && this.wdqs || this.mode !== 'wdqs' && this.lang && this.itemObject && this.propertyObject;
    };
    this.submit = function() {
      var data, field, ref, ref1, spec;
      data = {};
      if (this.mode === 'wdqs') {
        data.mode = 'wdqs';
        data.wdqs = this.wdqs;
      } else {
        for (field in fields) {
          spec = fields[field];
          if (field !== 'wdqs') {
            if ((ref = spec.type) === 'item' || ref === 'property') {
              data[field] = ((ref1 = this[field + 'Object']) != null ? ref1.id : void 0) || spec["default"];
            } else if (spec.type === 'boolean') {
              if (this[field] !== !!spec["default"]) {
                data[field] = ~~this[field];
              }
            } else {
              if (this[field] !== spec["default"]) {
                data[field] = this[field];
              }
            }
          }
        }
      }
      if (JSON.stringify($location.search()) === JSON.stringify(data)) {
        return rebuildFromUrl();
      } else {
        return $location.search(data);
      }
    };
    errorToast = function(message, more) {
      var toast;
      toast = $mdToast.simple().textContent(message).hideDelay(5000);
      if (more) {
        toast.action('More info').highlightAction(true);
      }
      return toast = $mdToast.show(toast).then((function(_this) {
        return function(response) {
          var tpl;
          if (more && response === 'ok') {
            tpl = angular.element("<md-dialog />").attr('aria-label', message).append(angular.element("<pre />").text(more));
            return $mdDialog.show({
              clickOutsideToClose: true,
              template: tpl[0].outerHTML
            });
          }
        };
      })(this));
    };
    regenSvg = (function(_this) {
      return function(data) {
        var insertError, insertSuccess, query, start_time;
        query = data.wdqs;
        start_time = new Date().getTime();
        insertSuccess = function(response) {
          _this.isLoading = false;
          _this.activeItem = data.item;
          return _this.graphData = response.data;
        };
        insertError = function(response) {
          var request_time;
          _this.isLoading = false;
          $log.error('unable to process answer', response.data);
          request_time = new Date().getTime() - start_time;
          if (request_time < 10 * 1000) {
            errorToast('Something is wrong with SPARQL query syntax', response.data);
          } else {
            errorToast('SPARQL query times out');
          }
        };
        _this.isLoading = true;
        WikiToolsService.wdqs(query).then(insertSuccess, insertError);
        _this.showSvg = true;
      };
    })(this);
    this.query = function() {
      var data;
      data = getDataFromUrl();
      window.open('https://query.wikidata.org/#' + encodeURIComponent(data.wdqs));
    };
    this.svg = function() {
      var serializer, source, url;
      serializer = new XMLSerializer();
      source = serializer.serializeToString($('svg')[0]);
      source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
      url = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(source);
      window.open(url);
    };
    this.list = function() {
      var data, ref, ref1, url;
      data = getDataFromUrl();
      url = "https://tools.wmflabs.org/wikidata-todo/tree.html?q=" + (data.item.slice(1));
      if ((ref = data.mode) === 'reverse' || ref === 'both') {
        url += "&rp=" + (data.property.slice(1));
      }
      if ((ref1 = data.mode) === 'forward' || ref1 === 'both') {
        url += "&p=" + (data.property.slice(1));
      }
      if (data.iterations !== 0) {
        url += "&depth=" + data.iterations;
      }
      if (data.lang !== 'en') {
        url += "&lang=" + data.lang;
      }
      window.open(url);
    };
  };

  FormCtrl.$inject = ['$scope', '$log', '$location', '$rootScope', '$mdToast', '$mdDialog', 'WikiToolsService', 'SparqlGenService'];

  app = angular.module('WgbApp', ['ngMaterial', 'WikiTools', 'Graph', 'SparqlGen']);

  app.config([
    '$locationProvider', function($locationProvider) {
      $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
      });
    }
  ]);

  app.controller('FormCtrl', FormCtrl);

}).call(this);
